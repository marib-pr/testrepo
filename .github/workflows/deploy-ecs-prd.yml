name: Deploy ECS to Production

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to create (e.g., prd-2025-10-24 or v1.2.3)'
        required: true
        type: string

permissions:
  contents: write
  actions: read

env:
  AWS_REGION: us-east-1
  # Fixed service metadata based on Terraform naming
  ENVIRONMENT: prd
  BPI_SERVICE: gain-assist
  BPI_STACK: portal
  ECR_REPOSITORY_NAME: gain-assist
  SLACK_RELEASE_WEBHOOK_URL: ${{ secrets.SLACK_RELEASE_WEBHOOK_URL }}

jobs:
  deploy:
    name: Deploy latest main to production and create release
    runs-on: ubuntu-latest
    steps:
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     aws-region: ${{ env.AWS_REGION }}
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # - name: Get AWS account ID
      #   id: aws
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
      #     echo "account_id=${ACCOUNT_ID}" >> "$GITHUB_OUTPUT"

      - name: Determine latest commit SHA on main
        id: sha
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          LATEST_SHA=$(curl -sSL -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/commits/main" | jq -r .sha)
          if [[ -z "${LATEST_SHA}" || "${LATEST_SHA}" == "null" ]]; then
            echo "Failed to determine latest commit SHA for main" >&2
            exit 1
          fi
          SHORT_SHA=${LATEST_SHA:0:7}
          echo "commit_sha=${LATEST_SHA}" >> "$GITHUB_OUTPUT"
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "--------------------------------"
          cat $GITHUB_OUTPUT

      # - name: Validate ECR image exists for tag
      #   id: ecr_image
      #   shell: bash
      #   env:
      #     COMMIT_SHA: ${{ steps.sha.outputs.commit_sha }}
      #   run: |
      #     set -euo pipefail
      #     REPO_NAME="${ECR_REPOSITORY_NAME}"
      #     echo "Checking ECR image ${REPO_NAME}:${COMMIT_SHA} in ${AWS_REGION}..."
      #     aws ecr describe-images \
      #       --repository-name "${REPO_NAME}" \
      #       --image-ids imageTag="${COMMIT_SHA}" \
      #       --region "${AWS_REGION}" \
      #       >/dev/null
      #     echo "ECR image exists."

      # - name: Prepare deployment variables
      #   id: vars
      #   shell: bash
      #   env:
      #     COMMIT_SHA: ${{ steps.sha.outputs.commit_sha }}
      #     ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
      #   run: |
      #     set -euo pipefail
      #     CLUSTER_NAME="${ENVIRONMENT}-${BPI_SERVICE}-${BPI_STACK}-cluster"
      #     SERVICE_NAME="${ENVIRONMENT}-${BPI_SERVICE}-${BPI_STACK}-service"
      #     FAMILY_NAME="${ENVIRONMENT}-${BPI_SERVICE}-${BPI_STACK}-task"
      #     CONTAINER_NAME="${BPI_SERVICE}-pipeline"
      #     ECR_IMAGE="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${COMMIT_SHA}"
      #     echo "cluster_name=${CLUSTER_NAME}" >> "$GITHUB_OUTPUT"
      #     echo "service_name=${SERVICE_NAME}" >> "$GITHUB_OUTPUT"
      #     echo "family_name=${FAMILY_NAME}" >> "$GITHUB_OUTPUT"
      #     echo "container_name=${CONTAINER_NAME}" >> "$GITHUB_OUTPUT"
      #     echo "new_image=${ECR_IMAGE}" >> "$GITHUB_OUTPUT"

      # - name: Fetch current task definition JSON
      #   id: fetch_td
      #   shell: bash
      #   env:
      #     FAMILY: ${{ steps.vars.outputs.family_name }}
      #   run: |
      #     set -euo pipefail
      #     aws ecs describe-task-definition \
      #       --task-definition "${FAMILY}" \
      #       --query 'taskDefinition' \
      #       --output json > taskdef_raw.json
      #     # Strip read-only fields not accepted by register-task-definition
      #     jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)' \
      #       taskdef_raw.json > taskdef_base.json

      # - name: Render task definition (set image)
      #   id: render_td
      #   uses: aws-actions/amazon-ecs-render-task-definition@v1
      #   with:
      #     task-definition: taskdef_base.json
      #     container-name: ${{ steps.vars.outputs.container_name }}
      #     image: ${{ steps.vars.outputs.new_image }}

      # - name: Deploy to ECS
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@v2
      #   with:
      #     task-definition: ${{ steps.render_td.outputs.task-definition }}
      #     service: ${{ steps.vars.outputs.service_name }}
      #     cluster: ${{ steps.vars.outputs.cluster_name }}
      #     wait-for-service-stability: true

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.event.inputs.tag }}
          target_commitish: ${{ steps.sha.outputs.commit_sha }}
          name: Production Release ${{ github.event.inputs.tag }}
          generate_release_notes: true

      - name: Fetch release data (for Slack)
        id: release_data
        if: success()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.event.inputs.tag }}
        run: |
          set -euo pipefail
          RESP=$(curl -sSL -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}")
          BODY=$(echo "$RESP" | jq -r '.body // "(no release notes)"')
          HTML_URL=$(echo "$RESP" | jq -r '.html_url')
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "html_url=${HTML_URL}" >> $GITHUB_OUTPUT
          echo "--------------------------------"
          cat $GITHUB_OUTPUT

      - name: Post release notes to Slack (bot)
        if: ${{ success() && secrets.SLACK_BOT_TOKEN != '' && secrets.SLACK_DEPLOY_ANNOUNCEMENTS_CHANNEL != '' }}
        shell: bash
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: ${{ secrets.SLACK_DEPLOY_ANNOUNCEMENTS_CHANNEL }}
          TAG_NAME: ${{ github.event.inputs.tag }}
          COMMIT_SHA: ${{ steps.sha.outputs.commit_sha }}
          RELEASE_URL: ${{ steps.release_data.outputs.html_url }}
        run: |
          set -euo pipefail
          NOTES_FILE=release_notes.txt
          echo "${{ steps.release_data.outputs.body }}" > "$NOTES_FILE"
          TEXT="*Production deployment completed*\n• Tag: ${TAG_NAME}\n• Commit: ${COMMIT_SHA}\n• Release: ${RELEASE_URL}\n\n*Release Notes:*\n$(cat "$NOTES_FILE")"
          PAYLOAD=$(jq -n --arg channel "$SLACK_CHANNEL" --arg text "$TEXT" '{channel: $channel, text: $text}')
          RESP=$(curl -sS -X POST \
            -H 'Content-type: application/json; charset=utf-8' \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            --data "$PAYLOAD" \
            https://slack.com/api/chat.postMessage)
          echo "$RESP" | jq -e '.ok == true' >/dev/null || { echo "Slack post failed: $RESP" >&2; exit 1; }


